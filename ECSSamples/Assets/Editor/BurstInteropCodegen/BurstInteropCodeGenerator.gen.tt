<#@ template language="C#" inherits="CodeGeneratorBase"#>

//------------------------------------------------------------------------------
// <auto-generated>
//     This file was automatically generated by <#=GetType()#>
//     Any changes you make here will be overwritten
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//     To update this file, use the "DOTS -> Regenerate Burst Interop" menu option.
//
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using Unity.Burst;
using Unity.Collections;
using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;

namespace <#= StructType.Namespace #>
{
    <# if (StructType.IsPublic) {#>public<#}#> unsafe partial struct <#= StructType.Name #>
    {

        [BurstDiscard]
        private static void CheckDelegate(ref bool useDelegate)
        {
            //@TODO: This should use BurstCompiler.IsEnabled once that is available as an efficient API.
            useDelegate = true;
        }

        private static bool UseDelegate()
        {
            bool result = false;
            CheckDelegate(ref result);
            return result;
        }

        static class Managed
        {
            public static bool _initialized = false;

<# foreach (var method in BurstTargetMethods) { #>
            public delegate <#= ReturnType(method) #> _dlg<#= method.Name #>(<#= PrototypeForDelegate(method) #>);
            public static _dlg<#= method.Name #> _bfp<#= method.Name #>;
<#}#>
<# foreach (var method in MonoTargetMethods) { #>
            public delegate <#= ReturnType(method) #> _dlg<#= method.Name #>(<#= PrototypeForDelegate(method) #>);
            public static object _gcDefeat<#= method.Name #>;
<#}#>
        }

<# foreach (var method in MonoTargetMethods) { #>
        struct TagType<#= method.Name#> {};
        public static readonly SharedStatic<IntPtr> _bfp<#= method.Name #> = SharedStatic<IntPtr>.GetOrCreate<TagType<#= method.Name #>>();
<#}#>

        [ExcludeFromBurstCompatTesting("Uses managed delegates")]
        internal static void Initialize()
        {
            if (Managed._initialized)
                return;
            Managed._initialized = true;
<#
   foreach (var method in BurstTargetMethods)
   {
#>
            Managed._bfp<#= method.Name #> = BurstCompiler.CompileFunctionPointer<Managed._dlg<#= method.Name #>>(_mono_to_burst<#= method.Name #>).Invoke;
<#
   }#>
<#
   foreach (var method in MonoTargetMethods)
   {
#>
        {
            Managed._dlg<#= method.Name #> delegateObject = _wrapper<#=method.Name#>;
            Managed._gcDefeat<#= method.Name #> = delegateObject;
            _bfp<#= method.Name #>.Data = Marshal.GetFunctionPointerForDelegate(delegateObject);
        }
<#
   }#>

        }

<# foreach (var method in BurstTargetMethods) { #>
        <#= GetAccessibility(method) #>  static <#= ReturnType(method) #> <#= method.Name.Substring(1) #> (<#= Prototype(method) #>)
        {
            if (UseDelegate())
            {
<#if (method.ReturnType == typeof(void)) {#>
                _forward_mono<#=method.Name#>(<#= CallArgs(method) #>);
                return;
<#} else {#>
                var _retval = default(<#=ReturnType(method)#>);
                _forward_mono<#=method.Name#>(ref _retval, <#= CallArgs(method) #>);
                return _retval;
<#}#>
            }

<#if (method.ReturnType == typeof(void)) {#>
            <#=method.Name#>(<#= CallArgs(method) #>);
<#} else {#>
            return <#=method.Name#>(<#= CallArgs(method) #>);
<#}#>
        }

        [BurstCompile]
        [MonoPInvokeCallback(typeof(Managed._dlg<#= method.Name #>))]
        private static <#= ReturnType(method) #> _mono_to_burst<#= method.Name #>(<#= PrototypeForDelegate(method) #>)
        {
<#if (method.ReturnType == typeof(void)) {#>
            <#=method.Name#>(<#= CallArgsMonoToBurst(method) #>);
<#} else {#>
            return <#=method.Name#>(<#= CallArgsMonoToBurst(method) #>);
<#}#>
        }

        [BurstDiscard]
<# if (method.ReturnType == typeof(void)) { #>
        private static void _forward_mono<#= method.Name #>(<#= Prototype(method) #>)
<#} else {#>
        private static void _forward_mono<#= method.Name #>(ref <#= ReturnType(method) #> _retval, <#= Prototype(method) #>)
<#}#>
        {
<#if (method.ReturnType == typeof(void)) {#>
            Managed._bfp<#=method.Name#>(<#= CallArgsForwardMono(method) #>);
<#} else {#>
            _retval = Managed._bfp<#=method.Name#>(<#= CallArgsForwardMono(method) #>);
<#}#>
        }

<#}#>

<#
   foreach (var method in MonoTargetMethods)
   {
#>
        <#= GetAccessibility(method) #> static <#= ReturnType(method) #> <#= method.Name.Substring(1) #> (<#= Prototype(method) #>)
        {
            if (!UseDelegate())
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                if( _bfp<#= method.Name #>.Data == IntPtr.Zero)
                    throw new InvalidOperationException("Burst Interop Classes must be initialized manually");
#endif

                var fp = new FunctionPointer<Managed._dlg<#= method.Name #>>(_bfp<#= method.Name #>.Data);
                fp.Invoke(<#= CallArgsForwardMono(method) #>);
                return;
            }
            <#=method.Name #>(<#= CallArgs(method) #>);
        }

        [MonoPInvokeCallback(typeof(Managed._dlg<#= method.Name #>))]
        private static <#= ReturnType(method) #> _wrapper<#= method.Name #> (<#= PrototypeForDelegate(method) #>)
        {
            <#=method.Name #>(<#= CallArgsMonoToBurst(method) #>);
        }
<#
   } #>


    }
}
