using Unity.Entities;
using Unity.Jobs;

[RequireMatchingQueriesForUpdate]
public partial class UpdateIdleTimerSystem : SystemBase
{
    // Cache a reference to this system in OnCreate() to prevent World.GetExistingSystem being called every frame
    private EndSimulationEntityCommandBufferSystem m_EndSimECBSystem;

    protected override void OnCreate()
    {
        m_EndSimECBSystem = World.GetExistingSystemManaged<EndSimulationEntityCommandBufferSystem>();
    }

    protected override void OnUpdate()
    {
        // ECB which will run at the end of the simulation group. If the player is seen, will change the Guard's state to chasing
        var ecb = m_EndSimECBSystem.CreateCommandBuffer().AsParallelWriter();

        // Grab our DeltaTime out of the system so it is usable by the ForEach lambda
        var deltaTime = SystemAPI.Time.DeltaTime;

        var updateHandle = Entities
            .WithName("UpdateTimer") // ForEach name is helpful for debugging
            .ForEach((
                Entity e, // Refers to the current guard entity. Used by the ECB when changing states
                int entityInQueryIndex, // Index of the guard entity in the query. Used for Concurrent ECB writing
                DynamicBuffer<WaypointPosition> waypoints,  // IBufferElementData T turns into DynamicBuffer<T> on the entity
                                                            // DynamicBuffer does not need to be passed in as "ref" or "in"
                ref IdleTimer idleTimer, // "ref" keyword makes this parameter ReadWrite
                ref NextWaypointIndex index,
                in CooldownTime cooldownTime) =>  // "in" keyword makes this parameter ReadOnly
                {
                    // Increment the timer by delta time
                    idleTimer.Value += deltaTime;

                    // If we have reached our maximum idle time
                    if (idleTimer.Value >= cooldownTime.Value)
                    {
                        // Remove the timer to leave the idle state
                        GuardAIUtility.TransitionFromIdle(ecb, e, entityInQueryIndex);

                        // Move to patrolling, using the next waypoint as our new TargetPosition
                        index.Value = (index.Value + 1) % waypoints.Length;
                        GuardAIUtility.TransitionToPatrolling(ecb, e, entityInQueryIndex, waypoints[index.Value].Value);
                    }
                }).ScheduleParallel(Dependency); // Schedule the ForEach with the job system to run

        // EntityCommandBufferSystem needs to know about all jobs which write to EntityCommandBuffers it has created
        m_EndSimECBSystem.AddJobHandleForProducer(updateHandle);

        // Pass the handle generated by the ForEach to the next system
        Dependency = updateHandle;
    }
}
